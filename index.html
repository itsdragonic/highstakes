<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VEX Robot Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
  <style>
    body {
      margin: 0;
      background-color: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    #game-container {
      position: relative;
      width: fit-content;
    }
    #game-canvas {
      display: block;
      background-color: transparent;
    }
    #background-canvas {
      position: absolute;
      top: -20px;
      left: -20px;
      z-index: -1;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
  </div>
  <canvas id="background-canvas"></canvas>

  <script>
    const SCALE = 4;
    const FIELD_SIZE = 144 * SCALE;
    const ROBOT_WIDTH = 14 * SCALE;
    const ROBOT_HEIGHT = 16.5 * SCALE;
    const BORDER_SIZE = 10;

    const fieldImage = new Image();
    fieldImage.src = "field.png";

    const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

    const engine = Engine.create();
    engine.gravity.x = 0;
    engine.gravity.y = 0;
    const world = engine.world;

    const bgCanvas = document.getElementById('background-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    bgCanvas.width = FIELD_SIZE + BORDER_SIZE * 2;
    bgCanvas.height = FIELD_SIZE + BORDER_SIZE * 2;

    const render = Render.create({
      canvas: document.getElementById('game-canvas'),
      engine: engine,
      options: {
        width: FIELD_SIZE,
        height: FIELD_SIZE,
        wireframes: false,
        background: 'transparent',
        showAngleIndicator: false
      }
    });

    function positionBackground() {
      const gameCanvas = document.getElementById('game-canvas');
      const rect = gameCanvas.getBoundingClientRect();
      bgCanvas.style.position = 'absolute';
      bgCanvas.style.left = (rect.left - BORDER_SIZE) + 'px';
      bgCanvas.style.top = (rect.top - BORDER_SIZE) + 'px';
    }

    function drawBackground() {
      if (fieldImage.complete) {
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        bgCtx.drawImage(fieldImage, 0, 0, bgCanvas.width, bgCanvas.height);
      } else {
        fieldImage.onload = function () {
          drawBackground();
          positionBackground();
        };
      }
    }

    window.addEventListener('resize', positionBackground);
    drawBackground();
    positionBackground();

    const robot = Bodies.rectangle(FIELD_SIZE / 2, FIELD_SIZE / 2, ROBOT_HEIGHT, ROBOT_WIDTH, {
      frictionAir: 0.2,
      render: {
        fillStyle: '#0077ff',
        visible: true
      }
    });

    const thickness = 20;
    const boundaries = [
      Bodies.rectangle(FIELD_SIZE / 2, -thickness / 2, FIELD_SIZE, thickness, { isStatic: true }),
      Bodies.rectangle(FIELD_SIZE / 2, FIELD_SIZE + thickness / 2, FIELD_SIZE, thickness, { isStatic: true }),
      Bodies.rectangle(-thickness / 2, FIELD_SIZE / 2, thickness, FIELD_SIZE, { isStatic: true }),
      Bodies.rectangle(FIELD_SIZE + thickness / 2, FIELD_SIZE / 2, thickness, FIELD_SIZE, { isStatic: true })
    ];

    const INCHES_TO_PIXELS = SCALE;
    const OBSTACLE_RADIUS = 4 * INCHES_TO_PIXELS;

    const obstaclePositions = [
      { x: 72, y: 48 },
      { x: 72, y: 97 },
      { x: 48, y: 72 },
      { x: 97, y: 72 }
    ];

    const obstacles = obstaclePositions.map(pos =>
      Bodies.circle(pos.x * INCHES_TO_PIXELS, pos.y * INCHES_TO_PIXELS, OBSTACLE_RADIUS, {
        isStatic: true,
        render: { fillStyle: 'transparent', visible: true }
      })
    );

    const HEXAGON_RADIUS = (12 / 2) * INCHES_TO_PIXELS;
    const HEXAGON_COLOR = '#bcc927';
    const hexagonPositions = [
      { x: 48, y: 48 },
      { x: 96, y: 48 },
      { x: 48, y: 96 },
      { x: 96, y: 96 },
      { x: 72, y: 121 },
    ];

    function createHexagon(x, y) {
      return Bodies.polygon(x, y, 6, HEXAGON_RADIUS, {
        friction: 1.0,
        frictionStatic: 1.0,
        restitution: 0,
        density: 0.5,
        angle: Math.PI / 6,
        render: {
          fillStyle: HEXAGON_COLOR,
          strokeStyle: '#000',
          lineWidth: 1
        }
      });
    }

    let hexagons = hexagonPositions.map(pos => createHexagon(pos.x * INCHES_TO_PIXELS, pos.y * INCHES_TO_PIXELS));

    const RING_OUTER_RADIUS = 7 / 2 * INCHES_TO_PIXELS;
    const RING_INNER_RADIUS = RING_OUTER_RADIUS - (2 * INCHES_TO_PIXELS);
    const RING_POSITIONS = [
      { x: 30, y: 30, color: 'red' },
      { x: 40, y: 30, color: 'red' },
      { x: 100, y: 100, color: 'blue' },
      { x: 120, y: 100, color: 'blue' }
    ];

    const rings = RING_POSITIONS.map(({ x, y, color }) => {
      const outer = Bodies.circle(x * INCHES_TO_PIXELS, y * INCHES_TO_PIXELS, RING_OUTER_RADIUS, {
        isSensor: false,
        restitution: 0.3,
        render: { visible: false } // We'll custom draw them later
      });
      const inner = Bodies.circle(x * INCHES_TO_PIXELS, y * INCHES_TO_PIXELS, RING_INNER_RADIUS, {
        isSensor: true,
        render: { visible: false }
      });
      return { outer, inner, color };
    });

    rings.forEach(ring => {
      World.add(world, [ring.outer, ring.inner]);
    });

    World.add(world, [robot, ...boundaries, ...obstacles, ...hexagons]);

    const keys = { w: false, a: false, s: false, d: false, r: false };
    const forceMagnitude = 0.02;
    const turnSpeed = 0.05;
    let attachedHexagon = null;
    let lastRState = false;

    document.addEventListener('keydown', e => { if (e.key in keys) keys[e.key] = true; });
    document.addEventListener('keyup', e => { if (e.key in keys) keys[e.key] = false; });

    Events.on(engine, 'beforeUpdate', () => {
      if (keys.r !== lastRState) {
        if (keys.r) {
          if (!attachedHexagon) {
            const backOffset = ROBOT_HEIGHT * 0.55;
            const backPosition = {
              x: robot.position.x - Math.cos(robot.angle) * backOffset,
              y: robot.position.y - Math.sin(robot.angle) * backOffset
            };
            let closestHexagon = null;
            let closestDistance = HEXAGON_RADIUS * 1.3;
            let closestIndex = -1;
            hexagons.forEach((hexagon, index) => {
              const distance = Matter.Vector.magnitude(Matter.Vector.sub(hexagon.position, backPosition));
              if (distance < closestDistance) {
                closestDistance = distance;
                closestHexagon = hexagon;
                closestIndex = index;
              }
            });
            if (closestHexagon) {
              World.remove(world, closestHexagon);
              hexagons.splice(closestIndex, 1);
              attachedHexagon = {
                position: { x: backPosition.x, y: backPosition.y },
                angle: robot.angle,
                radius: HEXAGON_RADIUS,
                color: HEXAGON_COLOR
              };
            }
          } else {
            const releasePosition = {
              x: robot.position.x - Math.cos(robot.angle) * ROBOT_HEIGHT,
              y: robot.position.y - Math.sin(robot.angle) * ROBOT_HEIGHT
            };
            const newHexagon = createHexagon(releasePosition.x, releasePosition.y);
            hexagons.push(newHexagon);
            World.add(world, newHexagon);
            attachedHexagon = null;
          }
        }
        lastRState = keys.r;
      }

      if (attachedHexagon) {
        const offset = ROBOT_HEIGHT * 0.6;
        attachedHexagon.position = {
          x: robot.position.x - Math.cos(robot.angle) * offset,
          y: robot.position.y - Math.sin(robot.angle) * offset
        };
        attachedHexagon.angle = robot.angle;
      }

      if (keys.a) Body.setAngularVelocity(robot, -turnSpeed);
      if (keys.d) Body.setAngularVelocity(robot, turnSpeed);
      if (keys.w || keys.s) {
        const angle = robot.angle;
        const dir = keys.w ? 1 : -1;
        Body.applyForce(robot, robot.position, {
          x: Math.cos(angle) * forceMagnitude * dir,
          y: Math.sin(angle) * forceMagnitude * dir
        });
      }
      if (!keys.a && !keys.d) Body.setAngularVelocity(robot, 0);
    });

    const drawFrontTriangle = (ctx, body) => {
      const angle = body.angle;
      const pos = body.position;
      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.rotate(angle + Math.PI / 2);
      ctx.beginPath();
      ctx.moveTo(0, -ROBOT_HEIGHT / 2 + 2);
      ctx.lineTo(-6, -ROBOT_HEIGHT / 2 + 12);
      ctx.lineTo(6, -ROBOT_HEIGHT / 2 + 12);
      ctx.closePath();
      ctx.fillStyle = 'yellow';
      ctx.fill();
      ctx.restore();
    };

    const drawAttachedHexagon = (ctx, hex) => {
      ctx.save();
      ctx.translate(hex.position.x, hex.position.y);
      ctx.rotate(hex.angle);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI / 3;
        const x = Math.cos(angle) * hex.radius;
        const y = Math.sin(angle) * hex.radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = hex.color;
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    };

    const drawRings = (ctx) => {
      rings.forEach(({ outer, color }) => {
        const x = outer.position.x;
        const y = outer.position.y;
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, RING_OUTER_RADIUS, 0, 2 * Math.PI, false);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, RING_INNER_RADIUS, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, RING_OUTER_RADIUS, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, RING_INNER_RADIUS, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
      });
    };

    Events.on(render, 'afterRender', () => {
      const ctx = render.context;
      drawFrontTriangle(ctx, robot);
      if (attachedHexagon) drawAttachedHexagon(ctx, attachedHexagon);
      drawRings(ctx);
    });

    Render.run(render);
    Runner.run(Runner.create(), engine);
  </script>
</body>
</html>
